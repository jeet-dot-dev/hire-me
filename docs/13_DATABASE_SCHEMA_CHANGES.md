# Database Schema Changes for Free Tier System

## 📋 Overview

This document details the database schema modifications made to support the free-tier restriction system. The changes are minimal, backward-compatible, and designed for future extensibility.

## 🗄️ Schema Modifications

### Candidate Model Update

#### Before
```prisma
model Candidate {
  id         String   @id @default(uuid())
  userId     String   @unique
  user       User     @relation(fields: [userId], references: [id])

  firstName  String
  lastName   String
  about      String?
  ProfilePic String? // R2 URL
  resumeUrl  String? // R2 URL

  education  Education[]
  skills     Skill[]
  socials    SocialLink[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  wishListedJobs String[]

  JobApplication JobApplication[]
}
```

#### After
```prisma
model Candidate {
  id         String   @id @default(uuid())
  userId     String   @unique
  user       User     @relation(fields: [userId], references: [id])

  firstName  String
  lastName   String
  about      String?
  ProfilePic String? // R2 URL
  resumeUrl  String? // R2 URL

  education  Education[]
  skills     Skill[]
  socials    SocialLink[]

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  wishListedJobs String[]
  interviewCredits Int @default(3) // Free tier interview attempts

  JobApplication JobApplication[]
}
```

#### Changes Made
- ✅ **Added**: `interviewCredits Int @default(3)`
- ✅ **Default Value**: 3 credits for all new candidates
- ✅ **Type**: Integer to support whole number credits
- ✅ **Nullable**: Non-nullable with default value ensures data integrity

## 🔍 Field Details

### interviewCredits Field Specification

#### Data Type
- **Type**: `Int` (32-bit signed integer)
- **Range**: -2,147,483,648 to 2,147,483,647
- **Storage**: 4 bytes per record

#### Default Value
- **Value**: `3`
- **Rationale**: Standard free tier allowance
- **Application**: Applied to all new candidate registrations

#### Constraints
- **NOT NULL**: Field cannot be null
- **Default**: Automatically set for new records
- **Validation**: Application-level validation ensures >= 0

#### Business Rules
```sql
-- Application-level constraints (not enforced at DB level)
-- interviewCredits >= 0 (no negative credits)
-- interviewCredits <= 1000 (reasonable upper limit for paid tiers)
```

## 🔄 Migration Strategy

### Database Migration Required

#### Migration File
```sql
-- Migration: Add interviewCredits to Candidate table
-- Generated by Prisma

BEGIN;

-- AlterTable
ALTER TABLE "Candidate" ADD COLUMN "interviewCredits" INTEGER NOT NULL DEFAULT 3;

COMMIT;
```

#### Migration Impact
- **Execution Time**: < 1 second for tables up to 1M records
- **Downtime**: Zero downtime migration (adds non-breaking field)
- **Storage Impact**: +4 bytes per candidate record
- **Index Impact**: No additional indexes required initially

### Backward Compatibility

#### Existing Data Handling
```sql
-- All existing candidates automatically get 3 credits
UPDATE "Candidate" SET "interviewCredits" = 3 WHERE "interviewCredits" IS NULL;
```

#### Application Compatibility
- ✅ Existing queries continue to work
- ✅ New field optional in SELECT statements
- ✅ Default value handles omitted field in INSERT statements

## 📊 Performance Considerations

### Query Performance Impact

#### Credit Check Queries
```sql
-- Typical credit check query
SELECT "interviewCredits" FROM "Candidate" WHERE "id" = $1;

-- Performance: ~1ms with proper indexing
-- No additional index needed for simple lookups by ID
```

#### Credit Update Queries
```sql
-- Credit deduction query
UPDATE "Candidate" 
SET "interviewCredits" = "interviewCredits" - 1 
WHERE "id" = $1 AND "interviewCredits" > 0;

-- Performance: ~2ms with row-level locking
-- Atomic operation prevents race conditions
```

### Indexing Strategy

#### Current Indexes (Sufficient)
```sql
-- Primary key index (automatic)
CREATE UNIQUE INDEX "Candidate_pkey" ON "Candidate"("id");

-- User relationship index (existing)
CREATE UNIQUE INDEX "Candidate_userId_key" ON "Candidate"("userId");
```

#### Optional Performance Index
```sql
-- Optional: Index for credit-based queries (if needed later)
CREATE INDEX "idx_candidate_credits" ON "Candidate"("interviewCredits")
WHERE "interviewCredits" >= 0;

-- Use case: Finding all candidates with specific credit levels
-- Only create if bulk credit operations become common
```

### Storage Analysis

#### Storage Overhead
```
Per Record Impact: +4 bytes
Database Size Impact: Minimal (< 0.1% for typical datasets)
Index Overhead: None (using existing primary key)
```

#### Capacity Planning
```sql
-- Current table size estimation
SELECT 
  schemaname,
  tablename,
  attname,
  n_distinct,
  most_common_vals,
  most_common_freqs
FROM pg_stats 
WHERE tablename = 'Candidate' AND attname = 'interviewCredits';
```

## 🔮 Future Extension Possibilities

### Subscription Tier Support

#### Enhanced Schema (Future)
```prisma
model Candidate {
  // ...existing fields...
  
  interviewCredits Int @default(3)
  subscriptionTier SubscriptionTier @default(FREE)
  subscriptionExpiresAt DateTime?
  
  // ...other fields...
}

enum SubscriptionTier {
  FREE
  BASIC
  PREMIUM
  ENTERPRISE
}
```

#### Credit Allocation by Tier
```typescript
const getCreditsByTier = (tier: SubscriptionTier): number => {
  switch (tier) {
    case 'FREE': return 3;
    case 'BASIC': return 25;
    case 'PREMIUM': return 100;
    case 'ENTERPRISE': return -1; // unlimited
    default: return 0;
  }
};
```

### Credit History Tracking (Future)

#### Credit Transaction Log
```prisma
model CreditTransaction {
  id            String   @id @default(uuid())
  candidateId   String
  candidate     Candidate @relation(fields: [candidateId], references: [id])
  
  type          CreditTransactionType
  amount        Int      // positive for additions, negative for deductions
  reason        String?  // "interview_attempt", "subscription_renewal", etc.
  
  createdAt     DateTime @default(now())
  
  @@index([candidateId, createdAt])
}

enum CreditTransactionType {
  DEDUCTION
  ADDITION
  REFUND
  BONUS
}
```

### Advanced Credit Features (Future)

#### Credit Expiration
```prisma
model CreditBalance {
  id            String   @id @default(uuid())
  candidateId   String
  candidate     Candidate @relation(fields: [candidateId], references: [id])
  
  credits       Int
  expiresAt     DateTime?
  source        String   // "free_tier", "subscription", "bonus"
  
  createdAt     DateTime @default(now())
  
  @@index([candidateId, expiresAt])
}
```

## 🧪 Data Validation & Testing

### Schema Validation Queries

#### Check Default Values
```sql
-- Verify all new candidates get default credits
SELECT COUNT(*) FROM "Candidate" WHERE "interviewCredits" = 3;

-- Check for any null values (should be 0)
SELECT COUNT(*) FROM "Candidate" WHERE "interviewCredits" IS NULL;
```

#### Data Integrity Checks
```sql
-- Verify no negative credits (application should prevent this)
SELECT COUNT(*) FROM "Candidate" WHERE "interviewCredits" < 0;

-- Check credit distribution
SELECT 
  "interviewCredits",
  COUNT(*) as candidate_count
FROM "Candidate" 
GROUP BY "interviewCredits" 
ORDER BY "interviewCredits";
```

### Application-Level Validation

#### Prisma Client Validation
```typescript
// Custom validation in application layer
const updateCandidateCredits = async (candidateId: string, newCredits: number) => {
  if (newCredits < 0) {
    throw new Error('Credits cannot be negative');
  }
  
  if (newCredits > 1000) {
    throw new Error('Credits exceed maximum allowed');
  }
  
  return await prisma.candidate.update({
    where: { id: candidateId },
    data: { interviewCredits: newCredits }
  });
};
```

#### Database Triggers (Optional)
```sql
-- Optional: Database-level validation trigger
CREATE OR REPLACE FUNCTION validate_interview_credits()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.interviewCredits < 0 THEN
    RAISE EXCEPTION 'Interview credits cannot be negative';
  END IF;
  
  IF NEW.interviewCredits > 10000 THEN
    RAISE EXCEPTION 'Interview credits exceed maximum limit';
  END IF;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_validate_credits
  BEFORE INSERT OR UPDATE ON "Candidate"
  FOR EACH ROW
  EXECUTE FUNCTION validate_interview_credits();
```

## 🔄 Migration Rollback Strategy

### Rollback Plan

#### Step 1: Remove Application Dependencies
```typescript
// Remove credit checks from application code
// Deploy version without credit validation
```

#### Step 2: Database Column Removal
```sql
-- Rollback migration
BEGIN;

-- Remove the column (WARNING: Data loss)
ALTER TABLE "Candidate" DROP COLUMN "interviewCredits";

COMMIT;
```

#### Step 3: Schema Update
```prisma
// Remove from Prisma schema
model Candidate {
  // Remove: interviewCredits Int @default(3)
  // ... rest of fields remain
}
```

### Data Backup Strategy

#### Pre-Migration Backup
```sql
-- Backup candidate data before migration
CREATE TABLE "Candidate_backup_pre_credits" AS 
SELECT * FROM "Candidate";
```

#### Credit Data Export
```sql
-- Export credit data for analysis/recovery
COPY (
  SELECT "id", "userId", "interviewCredits", "createdAt"
  FROM "Candidate"
) TO '/tmp/candidate_credits_backup.csv' CSV HEADER;
```

## 📈 Monitoring & Analytics

### Database Metrics to Track

#### Credit Usage Patterns
```sql
-- Daily credit consumption analytics
SELECT 
  DATE("updatedAt") as date,
  AVG("interviewCredits") as avg_credits,
  MIN("interviewCredits") as min_credits,
  MAX("interviewCredits") as max_credits,
  COUNT(*) as total_candidates
FROM "Candidate"
WHERE "updatedAt" >= NOW() - INTERVAL '30 days'
GROUP BY DATE("updatedAt")
ORDER BY date DESC;
```

#### Free Tier Conversion Opportunities
```sql
-- Candidates who have exhausted free credits
SELECT COUNT(*) as exhausted_candidates
FROM "Candidate" 
WHERE "interviewCredits" = 0;

-- Candidates close to exhaustion
SELECT COUNT(*) as low_credit_candidates
FROM "Candidate" 
WHERE "interviewCredits" = 1;
```

### Performance Monitoring

#### Query Performance Tracking
```sql
-- Monitor slow credit-related queries
SELECT 
  query,
  calls,
  total_time,
  mean_time,
  rows
FROM pg_stat_statements 
WHERE query LIKE '%interviewCredits%'
ORDER BY total_time DESC;
```

#### Lock Monitoring
```sql
-- Monitor credit update locks
SELECT 
  locktype,
  relation::regclass,
  mode,
  granted,
  pid
FROM pg_locks 
WHERE relation = 'Candidate'::regclass;
```

## 🔐 Security Considerations

### Data Access Control

#### Row-Level Security (Optional)
```sql
-- Optional: Restrict candidates to their own credit data
ALTER TABLE "Candidate" ENABLE ROW LEVEL SECURITY;

CREATE POLICY candidate_own_credits ON "Candidate"
  FOR ALL
  TO authenticated_users
  USING (user_id = auth.uid());
```

#### Application-Level Security
```typescript
// Ensure candidates can only access their own credits
const getCandidateCredits = async (userId: string) => {
  const candidate = await prisma.candidate.findUnique({
    where: { userId },
    select: { 
      id: true,
      interviewCredits: true 
    }
  });
  
  if (!candidate) {
    throw new Error('Candidate not found');
  }
  
  return candidate;
};
```

### Data Encryption

#### Column-Level Encryption (If Required)
```sql
-- Optional: Encrypt sensitive data (probably not needed for credits)
-- Most applications won't need this for credit counts
```

#### Audit Trail
```sql
-- Optional: Audit log for credit changes
CREATE TABLE credit_audit_log (
  id SERIAL PRIMARY KEY,
  candidate_id UUID NOT NULL,
  old_credits INT,
  new_credits INT,
  changed_by UUID,
  changed_at TIMESTAMP DEFAULT NOW(),
  reason TEXT
);
```

---

**Schema Version**: 1.1.0  
**Migration Date**: August 26, 2025  
**Backward Compatibility**: ✅ Full  
**Data Loss Risk**: ❌ None  
**Performance Impact**: ✅ Minimal  
**Rollback Complexity**: 🟡 Medium (with data loss)
